//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18444
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;


namespace AssemblyCSharp
{
	public class TerrainProtrusions
	{
		public static List<TerrainProtrusions> protrusions = new List<TerrainProtrusions>();
		public Vector2 center;
		public int radius;
		public bool isProtrusion;
		public float minHeight;
		public float maxHeight;

		public TerrainProtrusions (Vector2 center, int radius, float minHeight, float maxHeight, bool isProtrusion)
		{
			this.center = center;
			this.radius = radius;
			this.minHeight = minHeight;
			this.maxHeight = maxHeight;
			this.isProtrusion = isProtrusion;
		}

		public static void addProtrusion(TerrainProtrusions prot)
		{
			if (!protrusions.Contains (prot)) {
				protrusions.Add(prot);
			}
		}

		public static void modifyHeightMap(float[,] heights, float xOffset, float yOffset)
		{
			Vector2 dist;
			float mag;
			float height;
			foreach (TerrainProtrusions prot in protrusions) {
				for (int i = 0; i < heights.GetLength(0); i++)
				{
					for (int j = 0; j < heights.GetLength(1); j++)
					{
						dist = new Vector2(i,j);
						mag = (dist - new Vector2(prot.center.x - xOffset, prot.center.y - yOffset)).magnitude;
						
						if (mag > prot.radius)
							height = 1f;
						else{
							//Set the outer edge of the circle to be 0 and the center to be 1
							height = -(mag / ((float)prot.radius) - 1f);
							
							//Set up height for 
							height *= Mathf.PI;
							height -= Mathf.PI / 2;
							height = (Mathf.Sin(height) + 1) / 2;
							
							height = (height * (prot.maxHeight - prot.minHeight)) + prot.minHeight;
							//height = ((((float)radius) / mag) * (maxHeight - minHeight));// + minHeight;
						}
						if (prot.isProtrusion)
							heights[i,j] *= height;
						else
							heights[i,j] /= height;
					}
				}
			}
		}

		public static void createProtrusions(int minX, int minY, int maxX, int maxY, int minRadius, int maxRadius, float minHeight, float maxHeight, int minProt, int maxProt, bool isProtrusion)
		{
			System.Random r = new System.Random ();

			int numProt = r.Next (minProt, maxProt);
			int radius;
			int x, y;
			Vector2 center, dist;
			float height = minHeight;
			float mag;
			for (int k = 0; k < numProt; k++) {
				x = r.Next(minX, maxX);
				y = r.Next(minX, maxX);
				center = new Vector2(x,y);
				radius = r.Next(minRadius, maxRadius);
				addProtrusion(new TerrainProtrusions(center, radius, minHeight, maxHeight, isProtrusion));
			}
		}

		public int equals(TerrainProtrusions other)
		{
			if (center == other.center && radius == other.radius && isProtrusion == other.isProtrusion)
					return 1;
			else
					return 0;
		}
	}
}

